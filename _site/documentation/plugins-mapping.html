<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>Knockout : Mapping</title>
        <link href="../css/tripoli.simple.css" type="text/css" rel="stylesheet" /> 
        <link rel="stylesheet" type="text/css" href="../css/styles.css" />
        <link rel="stylesheet" type="text/css" href="../css/smallScreen.css" media="only screen and (max-device-width: 800px)" />
        <!--[if IE]><link rel="stylesheet" type="text/css" href="../css/tripoli.simple.ie.css" /><![endif]-->
        <!--[if lte IE 7]><link rel="stylesheet" type="text/css" href="../css/ie6ie7.css" /><![endif]-->
        <!--[if lte IE 6]><link rel="stylesheet" type="text/css" href="../css/ie6.css" /><![endif]-->
        <script type="text/javascript" src="../js/jquery-1.4.2.min.js"></script>
<script type="text/javascript" src="../js/knockout-2.1.0.js"></script>
<script type="text/javascript" src="../js/cufon-yui.js"></script>
<script type="text/javascript" src="../js/titilliummaps.font.js"></script>
<script type="text/javascript" src="../js/json2.js"></script>

<!--[if lt IE 7]>
<script defer type="text/javascript" src="../js/ie6pngfix.js"></script>
<![endif]-->

<script type="text/javascript" src="../js/syntaxhighlighter_3.0.83/scripts/shCore.js"></script> 
<script type="text/javascript" src="../js/syntaxhighlighter_3.0.83/scripts/shBrushJava.js"></script> 
<script type="text/javascript" src="../js/syntaxhighlighter_3.0.83/scripts/shBrushXml.js"></script> 
<link type="text/css" rel="stylesheet" href="../js/syntaxhighlighter_3.0.83/styles/shThemeFadeToGrey.css"/>  

<script type="text/javascript">
    $(function() {
        // Fancy fonts
        Cufon.replace('.titillium');
        Cufon.replace('.engraved', {
            textShadow: 'rgba(253, 224, 217, 0.45) 1.2px 1px'	
        });
        
        // Syntax highlighting
        $("pre > code").each(function() {
            var codeText = $(this).text();
            $(this).parent().text(codeText).addClass("brush:js");
        });
        SyntaxHighlighter.defaults['toolbar'] = false;
        SyntaxHighlighter.defaults['gutter'] = false;
        SyntaxHighlighter.all();
        
        // Highlight current top menu item
        var desiredMenuItem = '' || 'documentation';
        $(".main-menu a[rel=" + desiredMenuItem + "]").addClass("active");
        
        // Highlight current left-hand-nav menu item
        var urlFilename = location.href.match(/\/([^\/]+)$/);
        if (urlFilename) {
            $(".leftColContents li:has(a[href$=" + urlFilename[1] + "])").addClass("active");
        }
    });
</script> 
    </head>
    <body>
        <div id="wrapper">
            <div class="vspace"></div>
            <div class="main-menu">
    <ul>
        <li><a rel="home" href="../index.html">Home</a></li>
        <li><a rel="installation" href="../documentation/installation.html">Download / Install</a></li>
        <li><a rel="tutorials" href="http://learn.knockoutjs.com/">Tutorials</a></li>
        <li><a rel="examples" href="../examples/">Live examples</a></li>
        <li><a rel="documentation" href="../documentation/introduction.html">Documentation</a></li>
        <li><a href="http://groups.google.com/group/knockoutjs">Forum</a></li>
        <li><a href="http://github.com/SteveSanderson/knockout">Source</a></li>
    </ul>
</div>        	
<div class="clear"></div>
            <div class="vspace"></div>
            <div>	
	<div class="leftCol">		
		<div class="leftColBackground">&nbsp;</div>
		<div class="leftColContents">
			<h1>Getting started</h1>

<ol>
    <li><a href="introduction.html">How KO works and what benefits it brings</a></li>
    <li><a href="installation.html">Downloading and installing</a></li>
</ol>

<h1>Observables</h1>

<ol>
    <li><a href="observables.html">Creating <em>view models</em> with <em>observables</em></a></li>
    <li><a href="computedObservables.html">Using <em>computed observables</em></a></li>
    <li><a href="observableArrays.html">Working with <em>observable arrays</em></a></li>	
</ol>

<h1>Using built-in bindings</h1>

<h2>Controlling text and appearance</h2>
<ol>
    <li><a href="visible-binding.html">The <code>visible</code> binding</a></li>
    <li><a href="text-binding.html">The <code>text</code> binding</a></li>
    <li><a href="html-binding.html">The <code>html</code> binding</a></li>
    <li><a href="css-binding.html">The <code>css</code> binding</a></li>
    <li><a href="style-binding.html">The <code>style</code> binding</a></li>
    <li><a href="attr-binding.html">The <code>attr</code> binding</a></li>
</ol>

<h2>Control flow</h2>
<ol>
    <li><a href="foreach-binding.html">The <code>foreach</code> binding</a></li>
    <li><a href="if-binding.html">The <code>if</code> binding</a></li>
    <li><a href="ifnot-binding.html">The <code>ifnot</code> binding</a></li>
    <li><a href="with-binding.html">The <code>with</code> binding</a></li>
</ol>

<h2>Working with form fields</h2>
<ol>
    <li><a href="click-binding.html">The <code>click</code> binding</a></li>
    <li><a href="event-binding.html">The <code>event</code> binding</a></li>
    <li><a href="submit-binding.html">The <code>submit</code> binding</a></li>
    <li><a href="enable-binding.html">The <code>enable</code> binding</a></li>
    <li><a href="disable-binding.html">The <code>disable</code> binding</a></li>
    <li><a href="value-binding.html">The <code>value</code> binding</a></li>
    <li><a href="hasfocus-binding.html">The <code>hasfocus</code> binding</a></li>
    <li><a href="checked-binding.html">The <code>checked</code> binding</a></li>
    <li><a href="options-binding.html">The <code>options</code> binding</a></li>
    <li><a href="selectedOptions-binding.html">The <code>selectedOptions</code> binding</a></li>    
    <li><a href="uniqueName-binding.html">The <code>uniqueName</code> binding</a></li>		
</ol>

<h2>Creating custom bindings</h2>
<ol>
    <li><a href="custom-bindings.html">Creating custom bindings</a></li>
    <li><a href="custom-bindings-controlling-descendant-bindings.html">Controlling descendant bindings</a></li>
    <li><a href="custom-bindings-for-virtual-elements.html">Supporting virtual elements</a></li>
</ol>

<h2>Rendering templates</h2>
<ol>
    <li><a href="template-binding.html">The <code>template</code> binding</a></li>
</ol>

<h2>Further techniques</h2>
<ol>
    <li><a href="json-data.html">Loading and saving JSON data</a></li>
    <li><a href="extenders.html">Extending observables</a></li>
    <li><a href="throttle-extender.html">The <code>throttle</code> extender</a></li>
    <li><a href="unobtrusive-event-handling.html">Unobtrusive event handling</a></li>
    <li><a href="fn.html">Using <code>fn</code> to add custom functions</a></li>
</ol>

<h2>Plugins</h2>
<ol>
    <li><a href="plugins-mapping.html">The <code>mapping</code> plugin</a></li>
</ol>

<h1>More information</h1>
<ol>
    <li><a href="browser-support.html">Browser support</a></li>
    <li><a href="http://groups.google.com/group/knockoutjs">Getting help</a></li>
    <li><a href="links.html">Links to tutorials &amp; examples</a></li>
    <li><a href="amd-loading.html">Usage with AMD using RequireJs (Asynchronous Module Definition)</a></li>
</ol>

		</div>		
	</div>
	<div class="rightCol">
		<div class="documentation sticker">
		    <div class="content">
		    	<h1>Mapping</h1>	
		    	<p>Knockout is designed to allow you to use arbitrary JavaScript objects as view models. As long as some of your view model&#8217;s properties are <a href='observables.html'>observables</a>, you can use KO to bind to them to your UI, and the UI will be updated automatically whenever the observable properties change.</p>

<p>Most applications need to fetch data from a backend server. Since the server doesn&#8217;t have any concept of observables, it will just supply a plain JavaScript object (usually serialized as JSON). The mapping plugin gives you a straightforward way to map that plain JavaScript object into a view model with the appropriate observables. This is an alternative to manually writing your own JavaScript code that constructs a view model based on some data you&#8217;ve fetched from the server.</p>

<h3 id='download'>Download</h3>

<ul>
<li><strong><a href='https://github.com/SteveSanderson/knockout.mapping/tree/master/build/output'>Version 2.0</a></strong> (8.6kb minified)</li>
</ul>

<h3 id='example_manual_mapping_without_the_komapping_plugin'>Example: Manual mapping without the ko.mapping plugin</h3>

<p>You want to display the current server-time and the number of users on your web page. You could represent this information using the following view model:</p>

<pre><code>var viewModel = {
	serverTime: ko.observable(),
	numUsers: ko.observable()
}</code></pre>

<p>You could bind this view model to some HTML elements as follows:</p>

<pre><code>The time on the server is: &lt;span data-bind=&#39;text: serverTime&#39;&gt;&lt;/span&gt;
and &lt;span data-bind=&#39;text: numUsers&#39;&gt;&lt;/span&gt; user(s) are connected.</code></pre>

<p>Since the view model properties are observable, KO will automatically update the HTML elements whenever those properties change.</p>

<p>Next, you want to fetch the latest data from the server. Every 5 seconds you might issue an Ajax request (e.g., using jQuery&#8217;s <code>$.getJSON</code> or <code>$.ajax</code> functions):</p>

<pre><code>var data = getDataUsingAjax();			// Gets the data from the server</code></pre>

<p>The server might return JSON data similar to the following:</p>

<pre><code>{
	serverTime: &#39;2010-01-07&#39;,
	numUsers: 3
}</code></pre>

<p>Finally, to update your view model using this data (without using the mapping plugin), you would write:</p>

<pre><code>// Every time data is received from the server:
viewModel.serverTime(data.serverTime);
viewModel.numUsers(data.numUsers);</code></pre>

<p>You would have to do this for every variable you want to display on your page. If your data structures become more complex (e.g. they contain children or contain arrays) this becomes very cumbersome to handle manually. What the mapping plugin allows you to do is create a mapping from the regular JavaScript object (or JSON structure) to an observable view model.</p>

<h3 id='example_using_komapping'>Example: Using ko.mapping</h3>

<p>To create a view model via the mapping plugin, replace the creation of <code>viewModel</code> in the code above with the <code>ko.mapping.fromJS</code> function:</p>

<pre><code>var viewModel = ko.mapping.fromJS(data);</code></pre>

<p>This automatically creates observable properties for each of the properties on <code>data</code>. Then, every time you receive new data from the server, you can update all the properties on <code>viewModel</code> in one step by calling the <code>ko.mapping.fromJS</code> function again:</p>

<pre><code>// Every time data is received from the server:
ko.mapping.fromJS(data, viewModel);</code></pre>

<h3 id='how_things_are_mapped'>How things are mapped</h3>

<ul>
<li>All properties of an object are converted into an observable. If an update would change the value, it will update the observable.</li>

<li>Arrays are converted into <a href='observableArrays.html'>observable arrays</a>. If an update would change the number of items, it will perform the appropriate add/remove actions. It will also try to keep the order the same as the original JavaScript array.</li>
</ul>

<h3 id='unmapping'>Unmapping</h3>

<p>If you want to convert your mapped object back to a regular JS object, use:</p>

<pre><code>var unmapped = ko.mapping.toJS(viewModel);</code></pre>

<p>This will create an unmapped object containing only the properties of the mapped object that were part of your original JS object. So in other words, any properties or functions that you manually added to your view model are ignored. By default, the only exception to this rule is the <code>_destroy</code> property which will also be mapped back, because it is a property that Knockout may generate when you destroy an item from an <code>ko.observableArray</code>. See the &#8220;Advanced Usage&#8221; section for more details on how to configure this.</p>

<h3 id='working_with_json_strings'>Working with JSON strings</h3>

<p>If your Ajax call returns a JSON string (and does not deserialize it into a JavaScript object), then you can use the function <code>ko.mapping.fromJSON</code> to create and update your view model instead. To unmap, you can use <code>ko.mapping.toJSON</code>.</p>

<p>Apart from the fact that they work with JSON strings instead of JS objects these functions are completely identical to their <code>*JS</code> counterparts.</p>

<h3 id='advanced_usage'>Advanced usage</h3>

<p>Sometimes it may be necessary to have more control over how the mapping is performed. This is accomplished using <em>mapping options</em>. They can be specified during the <code>ko.mapping.fromJS</code> call. In subsequent calls you don&#8217;t need to specify them again.</p>

<p>Here a few situations in which you might want to use these mapping options.</p>

<h6 id='uniquely_identifying_objects_using_keys'>Uniquely identifying objects using &#8220;keys&#8221;</h6>

<p>Let&#8217;s say you have a JavaScript object that looks like this:</p>

<pre><code>var data = {
	name: &#39;Scot&#39;,
	children: [
		{ id : 1, name : &#39;Alicw&#39; }
	]
}</code></pre>

<p>You can map this to a view model without any problems:</p>

<pre><code>var viewModel = ko.mapping.fromJS(data);</code></pre>

<p>Now, let&#8217;s say the data is updated to be without any typos:</p>

<pre><code>var data = {
	name: &#39;Scott&#39;,
	children: [
		{ id : 1, name : &#39;Alice&#39; }
	]
}</code></pre>

<p>Two things have happened here: <code>name</code> was changed from <code>Scot</code> to <code>Scott</code> and <code>children[0].name</code> was changed from <code>Alicw</code> to the typo-free <code>Alice</code>. You can update <code>viewModel</code> based on this new data:</p>

<pre><code>ko.mapping.fromJS(data, viewModel);</code></pre>

<p>And <code>name</code> would have changed as expected. However, in the <code>children</code> array, the child (Alicw) would have been completely removed and a new one (Alice) added. This is not completely what you would have expected. Instead, you would have expected that only the <code>name</code> property of the child was updated from <code>Alicw</code> to <code>Alice</code>, not that the entire child was replaced!</p>

<p>This happens because, by default, the mapping plugin simply compares the two objects in the array. And since in JavaScript the object <code>{ id : 1, name : &#39;Alicw&#39; }</code> does not equal <code>{ id : 1, name : &#39;Alice&#39; }</code> it thinks that the <em>entire</em> child needs to be removed and replaced by a new one.</p>

<p>To solve this, you can specify which <code>key</code> the mapping plugin should use to determine if an object is new or old. You would set it up like this:</p>

<pre><code>var mapping = {
	&#39;children&#39;: {
		key: function(data) {
			return ko.utils.unwrapObservable(data.id);
		}
	}
}
var viewModel = ko.mapping.fromJS(data, mapping);</code></pre>

<p>This way, every time the mapping plugin checks an item in the <code>children</code> array, it will only look at the <code>id</code> property to determine if an object was completely replaced or merely needs updating.</p>

<h6 id='customizing_object_construction_using_create'>Customizing object construction using &#8220;create&#8221;</h6>

<p>If you want to handle a part of the mapping yourself, you can also provide a <code>create</code> callback. If this callback is present, the mapping plugin will allow you to do this part of the mapping yourself.</p>

<p>Let&#8217;s say you have a JavaScript object that looks like this:</p>

<pre><code>var data = {
	name: &#39;Graham&#39;,
	children: [
		{ id : 1, name : &#39;Lisa&#39; }
	]
}</code></pre>

<p>If you want to map the <code>children</code> array yourself, you can specify that like this:</p>

<pre><code>var mapping = {
	&#39;children&#39;: {
		create: function(options) {
			return new myChildModel(options.data);
		}
	}
}
var viewModel = ko.mapping.fromJS(data, mapping);</code></pre>

<p>The <code>options</code> argument supplied to your <code>create</code> callback is a JavaScript object containing:</p>

<ul>
<li><code>data</code>: The JavaScript object containing the data for this child</li>

<li><code>parent</code>: The parent object or array to which this child belongs</li>
</ul>

<p>Of course, inside the <code>create</code> callback you can do another call to <code>ko.mapping.fromJS</code> if you wish. A typical use-case might be if you want to augment the original JavaScript object with some additional <a href='computedObservables.html'>computed observables</a>:</p>

<pre><code>var myChildModel = function(data) {
	ko.mapping.fromJS(data, {}, this);
	
	this.nameLength = ko.computed(function() {
		return this.name().length;
	}, this);
}</code></pre>

<h6 id='customizing_object_updating_using_update'>Customizing object updating using &#8220;update&#8221;</h6>

<p>You can also customize how an object is updated by specifying an <code>update</code> callback. It will receive the object it is trying to update and an <code>options</code> object which is identical to the one used by the <code>create</code> callback. You should <code>return</code> the updated value.</p>

<p>The <code>options</code> argument supplied to your <code>update</code> callback is a JavaScript object containing:</p>

<ul>
<li><code>data</code>: The JavaScript object containing the data for this child</li>

<li><code>parent</code>: The parent object or array to which this child belongs</li>

<li><code>observable</code>: If the property is an observable, this will be set to the actual observable</li>
</ul>

<p>Here is an example of a configuration that will add some text to the incoming data before updating:</p>

<pre><code>var data = {
	name: &#39;Graham&#39;,
}

var mapping = {
	&#39;name&#39;: {
		update: function(options) {
			return options.data + &#39;foo!&#39;;
		}
	}
}
var viewModel = ko.mapping.fromJS(data, mapping);
alert(viewModel.name());</code></pre>

<p>This will alert <code>Grahamfoo!</code>.</p>

<h6 id='ignoring_certain_properties_using_ignore'>Ignoring certain properties using &#8220;ignore&#8221;</h6>

<p>If you want the mapping plugin to ignore some properties of your JS object (i.e. to not map them), you can specify a array of propertynames to ignore:</p>

<pre><code>var mapping = {
	&#39;ignore&#39;: [&quot;propertyToIgnore&quot;, &quot;alsoIgnoreThis&quot;]
}
var viewModel = ko.mapping.fromJS(data, mapping);</code></pre>

<p>The <code>ignore</code> array you specify in the mapping options is combined with the default <code>ignore</code> array. You can manipulate this default array like this:</p>

<pre><code>var oldOptions = ko.mapping.defaultOptions().ignore;
ko.mapping.defaultOptions().ignore = [&quot;alwaysIgnoreThis&quot;];</code></pre>

<h6 id='including_certain_properties_using_include'>Including certain properties using &#8220;include&#8221;</h6>

<p>When converting your view model back to a JS object, by default the mapping plugin will only include properties that were part of your original view model, except it will also include the Knockout-generated <code>_destroy</code> property even if it was not part of your original object. However, you can choose to customize this array:</p>

<pre><code>var mapping = {
	&#39;include&#39;: [&quot;propertyToInclude&quot;, &quot;alsoIncludeThis&quot;]
}
var viewModel = ko.mapping.fromJS(data, mapping);</code></pre>

<p>The <code>include</code> array you specify in the mapping options is combined with the default <code>include</code> array, which by default only contains <code>_destroy</code>. You can manipulate this default array like this:</p>

<pre><code>var oldOptions = ko.mapping.defaultOptions().include;
ko.mapping.defaultOptions().include = [&quot;alwaysIncludeThis&quot;];</code></pre>

<h6 id='copying_certain_properties_using_copy'>Copying certain properties using &#8220;copy&#8221;</h6>

<p>When converting your view model back to a JS object, by default the mapping plugin will create observables based on the rules explained <a href='#how_things_are_mapped'>above</a>. If you want to force the mapping plugin to simply copy the property instead of making it observable, add its name to the &#8220;copy&#8221; array:</p>

<pre><code>var mapping = {
	&#39;copy&#39;: [&quot;propertyToCopy&quot;]
}
var viewModel = ko.mapping.fromJS(data, mapping);</code></pre>

<p>The <code>copy</code> array you specify in the mapping options is combined with the default <code>copy</code> array, which by default is empty. You can manipulate this default array like this:</p>

<pre><code>var oldOptions = ko.mapping.defaultOptions().copy;
ko.mapping.defaultOptions().copy = [&quot;alwaysCopyThis&quot;];</code></pre>

<h6 id='specifying_the_update_target'>Specifying the update target</h6>

<p>If, like in the example above, you are performing the mapping inside of a class, you would like to have <code>this</code> as the target of your mapping operation. The third parameter to <code>ko.mapping.fromJS</code> indicates the target. For example,</p>

<pre><code>ko.mapping.fromJS(data, {}, someObject); // overwrites properties on someObject</code></pre>

<p>So, if you would like to map a JavaScript object to <code>this</code>, you can pass <code>this</code> as the third argument:</p>

<pre><code>ko.mapping.fromJS(data, {}, this);</code></pre>

<h5 id='mapping_from_multiple_sources'>Mapping from multiple sources</h5>

<p>You can combine multiple JS objects in one viewmodel by applying multiple <code>ko.mapping.fromJS</code> calls, e.g.:</p>

<pre><code>var viewModel = ko.mapping.fromJS(alice, aliceMappingOptions);
ko.mapping.fromJS(bob, bobMappingOptions, viewModel);</code></pre>

<p>Mapping options that you specify in each call will be merged.</p>

<h5 id='mapped_observable_array'>Mapped observable array</h5>

<p>Observable arrays that are generated by the mapping plugin are augmented with a few functions that can make use of the <code>keys</code> mapping:</p>

<ul>
<li>mappedRemove</li>

<li>mappedRemoveAll</li>

<li>mappedDestroy</li>

<li>mappedDestroyAll</li>

<li>mappedIndexOf</li>
</ul>

<p>They are functionally equivalent to the regular <code>ko.observableArray</code> functions, but can do things based on the key of the object. For example, this would work:</p>

<pre><code>var obj = [
    { id : 1 },
    { id : 2 }
]

var result = ko.mapping.fromJS(obj, {
    key: function(item) {
        return ko.utils.unwrapObservable(item.id);
    }
});

result.mappedRemove({ id : 2 });</code></pre>

<p>The mapped observable array also exposes a <code>mappedCreate</code> function:</p>

<pre><code>var newItem = result.mappedCreate({ id : 3 });</code></pre>

<p>It will first check if the key is already present and will throw an exception if it is. Next, it will invoke the create and update callbacks, if any, to create the new object. Finally, it will add this object to the array and return it.</p>

<h3 id='download'>Download</h3>

<ul>
<li><strong><a href='https://github.com/SteveSanderson/knockout.mapping/tree/master/build/output'>Version 2.0</a></strong> (8.6kb minified)</li>
</ul>    
		    </div>
		    
		    <div class="clear"></div>
		</div>
	</div>	
</div>
            <div class="clear"></div>
            <div class="main-menu">
    <ul>
        <li><a rel="home" href="../index.html">Home</a></li>
        <li><a rel="installation" href="../documentation/installation.html">Download / Install</a></li>
        <li><a rel="tutorials" href="http://learn.knockoutjs.com/">Tutorials</a></li>
        <li><a rel="examples" href="../examples/">Live examples</a></li>
        <li><a rel="documentation" href="../documentation/introduction.html">Documentation</a></li>
        <li><a href="http://groups.google.com/group/knockoutjs">Forum</a></li>
        <li><a href="http://github.com/SteveSanderson/knockout">Source</a></li>
    </ul>
</div>        	
<div class="clear"></div>
        </div>
        
        <div id="page-footer">(c) knockoutjs.com</div> 
        
		  <script type="text/javascript">
		
		  var _gaq = _gaq || [];
		  _gaq.push(['_setAccount', 'UA-32297409-1']);
		  _gaq.push(['_trackPageview']);
		
		  (function() {
		    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
		    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
		    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		  })();
		
			</script>
    </body>
</html>